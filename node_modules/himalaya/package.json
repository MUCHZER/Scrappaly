{
  "name": "himalaya",
  "version": "0.2.0",
  "description": "HTML to JSON parser",
  "main": "index.js",
  "bin": {
    "himalaya": "./bin/himalaya.js"
  },
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/andrejewski/himalaya.git"
  },
  "keywords": [
    "html",
    "parser",
    "ast",
    "json"
  ],
  "author": {
    "name": "Chris Andrejewski",
    "email": "christopher.andrejewski@gmail.com"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/andrejewski/himalaya/issues"
  },
  "homepage": "https://github.com/andrejewski/himalaya",
  "devDependencies": {
    "mocha": "^2.2.5"
  },
  "dependencies": {
    "paul": "0.0.3"
  },
  "readme": "# Himalaya\n\nHimalaya is a pure JavaScript HTML parser that converts HTML into JSON, which can then be further manipulated by other modules.\n\n```bash\nnpm install himalaya\n```\n\n## Usage\n\n```js\nvar himalaya = require('himalaya');\nvar html = require('fs').readFileSync('/webpage.html');\nvar json = himalaya.parse(html);\n```\n\nInstalled globally, Himalaya can also be used from the command-line to convert HTML files to JSON files, or as a pipe transform.\n\n```bash\nhimalaya webpage.html webpage.json\n# or as a pipe\necho \"<h1>Hello</h1>\" | himalaya > hello.json\n```\n\nRun `himalaya --help` for more information.\n\n## Parser AST Specification\n\nHimalaya has a specification for its output. Essentially, everything is a node and can either be an `Element`, `Comment`, or `Text` node. The [full specification](https://github.com/andrejewski/himalaya/tree/master/docs/ast-spec.md) provides the complete details.\n\n### Example Input/Output\n\n```html\n<div class='post post-featured'>\n\t<p>Himalaya parsed me...</p>\n\t<!-- ...and I liked it. -->\n</div>\n```\n\n```json\n[\n  {\n    \"type\": \"Element\",\n    \"tagName\": \"div\",\n    \"attributes\": {\n      \"className\": [\n        \"post\",\n        \"post-featured\"\n      ]\n    },\n    \"children\": [\n      {\n        \"type\": \"Element\",\n        \"tagName\": \"p\",\n        \"attributes\": {},\n        \"children\": [\n          {\n            \"type\": \"Text\",\n            \"content\": \"Himalaya parsed me...\"\n          }\n        ]\n      },\n      {\n        \"type\": \"Comment\",\n        \"content\": \" ...and I liked it. \",\n      }\n    ]\n  }\n]\n```\n\n*Note:* Text nodes containing only whitespace were removed from the output for readability.\n\n## Features\n\n### Synchronous \nHTML is turned into JSON, that's it. Himalaya is completely synchronous and does not require any complicated callbacks. \n\n### Parses Attributes\nHimalaya does a couple things when processing attributes:\n- Camel-cases attribute names\n- Attributes without values are set to their names (i.e. `disabled` turns into `disabled=\"disabled\"`)\n- Groups `data-*` attributes into a `dataset` object\n- Attempts to caste any value to a number if `!Nan`\n- Parses the `style` attribute into a hash map\n\n### Handles Weirdness\nHimalaya handles a lot of HTML's fringe cases, like:\n- Closes unclosed tags `<p><b>...</p>`\n- Ignores extra closing tags `<span>...</b></span>`\n- Properly handles void tags like `<meta>` and `<img>`\n- Properly handles self-closing tags like `<input/>`\n- Handles `<!doctype>` and `<-- comments -->`\n- Does not parse the contents of `<script>`, `<style>`, and HTML5 `<template>` tags\n\n### Preserves Whitespace\nHimalaya does not cut corners and returns an accurate representation of the HTML supplied.\n\n## Going back to HTML\nHimalaya provides translation functions that can take the Himalaya AST and output eqivalent HTML and Jade.\n\nThe following example does absolutely nothing. It simply parses the HTML to JSON then parses the JSON back into HTML, which is the exact same as the original. (Of course if the original was malformed, Himalaya probably buffed out the kinks.)\n\n```js\nvar fs = require('fs');\nvar himalaya = require('himalaya');\nvar toHTML = require('himalaya/translate').toHTML;\n\nvar html = fs.readFileSync('/webpage.html');\nvar json = himalaya.parse(html);\nfs.writeFileSync('/webpage.html', toHTML(json));\n```\n\nThe same can be done with [Jade](http://jade-lang.com/) using the `toJade` function of the same module. These functions have additional options which can be found in their [reference document for translations](https://github.com/andrejewski/himalaya/tree/master/docs/translation.md).\n\n## Why \"Himalaya\"?\n\n[First, my friends weren't very helpful.](https://twitter.com/compooter/status/597908517132042240) Except Josh, Josh had my back.\n\nWhile I was testing the parser, I threw a download of my Twitter homepage in and got a huge JSON blob out. My code editor Sublime Text has a mini-map and looking at it sideways the data looked like a never-ending mountain range. Also, \"himalaya\" has H, M, L in it.\n\n## Nerd Stuff\n\nMy first implementation used look-ahead, found the matching closing tag, and then recursively parsed the inners until a tree was built. That was problematic. This implementation uses no look-ahead and instead uses a stack to keep track of nesting as the source string is cut away. When an end tag is found the stack it cut to match and then parsing picks up again at the higher level. \n\nThis parser was implemented without using any regular expressions. Since I wanted this to double as a learning resource, I wanted the code to be readable sans regexes.\n\n## Contributing\n\nWe can always have more tests: if you find a bug, create an issue or be **fabulous** and fix the problem and write the tests up yourself in a coherent pull request.\n\nRun tests with the `npm test` command.\n\nFollow me on [Twitter](https://twitter.com/compooter) for updates or just for the lolz and please check out my other [repositories](https://github.com/andrejewski) if I have earned it. I thank you for reading.\n",
  "readmeFilename": "README.md",
  "_id": "himalaya@0.2.0",
  "_from": "himalaya@"
}
